<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class RcPdfLayout::Object::TextBox - rcpdflayout documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="../Object.html">RcPdfLayout::Object</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-render_text">::render_text</a>
    
    <li ><a href="#method-i-render_final">#render_final</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-RcPdfLayout::Object::TextBox">
  <h1 id="class-RcPdfLayout::Object::TextBox" class="class">
    class RcPdfLayout::Object::TextBox
  </h1>

  <section class="description">
    
<p>A bounded text container.</p>

<p><code>TextBox</code> will automatically perform line wrapping of text, should the lines of text to be rendered not fit within the width of the boundary, but line breaks can also be made explicit.</p>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-color" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">color</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The default foreground color to render the inner text segments with @return [String]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-font_name" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">font_name</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The font to render the inner text segments with @return [String]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-font_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">font_size</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The font size to render the inner text segments with @return [Integer]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-text_segment_lines" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">text_segment_lines</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The text markup segments to render within this text box, where each line is an array of hashes (the output of a parsing function within +RcPdfLayout::TextMarkup).</p>

<p>@return [Array&lt;Array&lt;Hash&gt;&gt;]</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(position_mm, size_mm, ppi, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new text box object. @param position_mm [Array&lt;Float&gt;] The position of the object on the page,</p>

<pre>as an array of +x, y+ positions, in millimeters, from the top left of
the page</pre>

<p>@param size_mm [Array&lt;Float&gt;] The size of the object, as an array of</p>

<pre>+width, height+, in millimeters</pre>

<p>@param ppi [Integer] Number of pixels per inch for this object, used for</p>

<pre>creating the base image object, and final rendering</pre>
          
          
            <div class="method-calls-super">
              Calls superclass method
              <a href="../Object.html#method-c-new"><code>RcPdfLayout::Object::new</code></a>
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/rcpdflayout/object/text_box.rb, line 36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">position_mm</span>, <span class="ruby-identifier">size_mm</span>, <span class="ruby-identifier">ppi</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge!</span>({ <span class="ruby-value">defer_image:</span> <span class="ruby-keyword">true</span> })
  <span class="ruby-keyword">super</span>(<span class="ruby-identifier">position_mm</span>, <span class="ruby-identifier">size_mm</span>, <span class="ruby-identifier">ppi</span>, <span class="ruby-identifier">opts</span>)

  <span class="ruby-ivar">@font_name</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:font</span>, <span class="ruby-string">&#39;DeJaVu-Sans&#39;</span>)
  <span class="ruby-ivar">@font_size</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:font_size</span>, <span class="ruby-value">12</span>)
  <span class="ruby-ivar">@color</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:color</span>, <span class="ruby-string">&#39;black&#39;</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-render_text" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">render_text</span><span
            class="method-args">(segments, width_mm, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Renders the given <code>segments</code> (the output of a parsing function within <code>RcPdfLayout::TextMarkup</code>) into an array containing arrays of <code>RcPdfLayout::Object::TextSegment</code> objects, performing line wrapping where needed to fit the text within the given boundary (where the boundary is defined as <code>width_mm</code> wide).</p>

<p>@param segments [Array&lt;Hash&gt;] @param width_mm [Float] The width of the text boundary, in millimeters @param opts [Hash] Text segment creation options @return [Array&lt;Array&lt;RcPdfLayout::Object::TextSegment&gt;&gt;]</p>

<pre>An array of arrays of text segment objects, where each inner array
represents a single line of text that fits within the boundary.</pre>
          
          

          
          <div class="method-source-code" id="render_text-source">
            <pre><span class="ruby-comment"># File lib/rcpdflayout/object/text_box.rb, line 119</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">render_text</span>(<span class="ruby-identifier">segments</span>, <span class="ruby-identifier">width_mm</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-identifier">ppi</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:force_ppi</span>, <span class="ruby-value">72</span>)
  <span class="ruby-identifier">lines</span> = []

  <span class="ruby-identifier">line_segs</span> = []
  <span class="ruby-identifier">line_xpos</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">segments</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">seg</span>, <span class="ruby-identifier">_idx</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">rseg</span> = <span class="ruby-operator">::</span><span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">Object</span><span class="ruby-operator">::</span><span class="ruby-constant">TextSegment</span>.<span class="ruby-identifier">from_markup_segment</span>([<span class="ruby-identifier">line_xpos</span>, <span class="ruby-value">0</span>], <span class="ruby-identifier">seg</span>, <span class="ruby-identifier">opts</span>)
    <span class="ruby-identifier">rimg</span> = <span class="ruby-identifier">rseg</span>.<span class="ruby-identifier">render_final</span>(<span class="ruby-value">force_ppi:</span> <span class="ruby-identifier">ppi</span>)

    <span class="ruby-comment"># Get width in millimeters of our rendered segment, use that to check</span>
    <span class="ruby-comment"># if we&#39;ve run past the boundary, and to bump line_xpos if we haven&#39;t</span>
    <span class="ruby-identifier">r_width_mm</span> = (<span class="ruby-identifier">rimg</span>.<span class="ruby-identifier">width</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">ppi</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">MM_TO_INCH</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">r_width_mm</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">width_mm</span>
      <span class="ruby-comment"># We need to decide here whether to just wholly bump this segment</span>
      <span class="ruby-comment"># to the next line, or to break it. Here&#39;s the logic.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># If we would need to split this segment near the start (which</span>
      <span class="ruby-comment"># we&#39;ll define as &quot;less than one half of it&#39;s current width&quot;),</span>
      <span class="ruby-comment"># just bump it entirely to the next line.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># Otherwise, split it as close to the boundary as we can, allowing</span>
      <span class="ruby-comment"># for the insertion of an ASCII hyphen character at the end of the</span>
      <span class="ruby-comment"># current line to signify continuation.</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">r_width_mm</span> <span class="ruby-operator">/</span> <span class="ruby-value">2</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">width_mm</span>
        <span class="ruby-comment"># Bump to next line</span>
        <span class="ruby-identifier">lines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">line_segs</span>
        <span class="ruby-identifier">line_segs</span> = []
        <span class="ruby-identifier">line_xpos</span> = <span class="ruby-value">0</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># Duplicate of the original check: if we&#39;re longer than the line</span>
      <span class="ruby-comment"># will allow (even after a potential line bump), then split the</span>
      <span class="ruby-comment"># segment. Otherwise, append to the current line as usual</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">r_width_mm</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">width_mm</span>
        <span class="ruby-comment"># Do a rough guess as to where we need to split based on the</span>
        <span class="ruby-comment"># length of the segment&#39;s text (in characters) compared to the</span>
        <span class="ruby-comment"># segment&#39;s width (in millimeters). This assumes a monospace</span>
        <span class="ruby-comment"># font, but it gets us Close Enough™ to where we need to be, and</span>
        <span class="ruby-comment"># we can adjust from there</span>

        <span class="ruby-identifier">r_text</span> = <span class="ruby-identifier">seg</span>[<span class="ruby-value">:word</span>]
        <span class="ruby-identifier">r_char_width</span> = (<span class="ruby-identifier">r_width_mm</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">length</span>).<span class="ruby-identifier">to_f</span>
        <span class="ruby-identifier">line_avspace</span> = <span class="ruby-identifier">width_mm</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">line_xpos</span>
        <span class="ruby-identifier">r_split_chars</span> = (<span class="ruby-identifier">line_avspace</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">r_char_width</span>).<span class="ruby-identifier">floor</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>

        <span class="ruby-keyword">until</span> <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">r_text</span>&amp;.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">r_split_seg</span> = <span class="ruby-identifier">seg</span>.<span class="ruby-identifier">dup</span>
          <span class="ruby-identifier">r_split_seg</span>[<span class="ruby-value">:word</span>] = <span class="ruby-identifier">r_text</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">r_split_chars</span>]
          <span class="ruby-identifier">r_split_seg</span>[<span class="ruby-value">:word</span>] <span class="ruby-operator">+=</span> <span class="ruby-string">&#39;-&#39;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">r_split_seg</span>[<span class="ruby-value">:word</span>].<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">length</span>

          <span class="ruby-identifier">r_split_tseg</span> = <span class="ruby-operator">::</span><span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">Object</span><span class="ruby-operator">::</span><span class="ruby-constant">TextSegment</span>.<span class="ruby-identifier">from_markup_segment</span>([<span class="ruby-identifier">line_xpos</span>, <span class="ruby-value">0</span>], <span class="ruby-identifier">r_split_seg</span>, <span class="ruby-identifier">opts</span>)
          <span class="ruby-identifier">r_split_timg</span> = <span class="ruby-identifier">r_split_tseg</span>.<span class="ruby-identifier">render_final</span>(<span class="ruby-value">force_ppi:</span> <span class="ruby-identifier">ppi</span>)
          <span class="ruby-identifier">r_split_width_mm</span> = (<span class="ruby-identifier">r_split_timg</span>.<span class="ruby-identifier">width</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">ppi</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">MM_TO_INCH</span>

          <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">r_split_width_mm</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">width_mm</span>
            <span class="ruby-comment"># Try again :(</span>
            <span class="ruby-identifier">r_split_chars</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>

            <span class="ruby-keyword">if</span> <span class="ruby-identifier">r_split_chars</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
              <span class="ruby-comment"># Can&#39;t do anything, bump to next line</span>
              <span class="ruby-identifier">lines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">line_segs</span>
              <span class="ruby-identifier">line_segs</span> = []
              <span class="ruby-identifier">line_xpos</span> = <span class="ruby-value">0</span>
              <span class="ruby-identifier">r_split_chars</span> = <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">length</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-keyword">next</span>

          <span class="ruby-keyword">else</span>
            <span class="ruby-comment"># We&#39;re good! Append this text segment to the current line,</span>
            <span class="ruby-comment"># cut +r_text+ at the length of the split, check if we need</span>
            <span class="ruby-comment"># to create a new line (and do so), and maybe iterate again.</span>
            <span class="ruby-identifier">line_segs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r_split_tseg</span>
            <span class="ruby-identifier">r_text</span> = <span class="ruby-identifier">r_text</span>[(<span class="ruby-identifier">r_split_chars</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)<span class="ruby-operator">..</span>]

            <span class="ruby-comment"># If +r_text+ is now empty, we&#39;re at the end of this segment,</span>
            <span class="ruby-comment"># so we don&#39;t need to create a new line.</span>
            <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">r_text</span>&amp;.<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">lines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">line_segs</span>
              <span class="ruby-identifier">line_segs</span> = []
              <span class="ruby-identifier">line_xpos</span> = <span class="ruby-value">0</span>
              <span class="ruby-identifier">r_split_chars</span> = <span class="ruby-identifier">r_text</span>.<span class="ruby-identifier">length</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">r_width_mm</span>
        <span class="ruby-identifier">line_segs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rseg</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># Append the segment to the current line and bump line_xpos</span>
      <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">r_width_mm</span>
      <span class="ruby-identifier">line_segs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rseg</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># We got to the end! Throw the current segments in and return the list</span>
  <span class="ruby-identifier">lines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">line_segs</span>
  <span class="ruby-identifier">lines</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-render_final" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">render_final</span><span
            class="method-args">(opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return this text box as a rendered image</p>

<p>@param opts [Hash] Render options @return [MiniMagick::Image] Rendered image</p>
          
          

          
          <div class="method-source-code" id="render_final-source">
            <pre><span class="ruby-comment"># File lib/rcpdflayout/object/text_box.rb, line 49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">render_final</span>(<span class="ruby-identifier">opts</span> = {})
  <span class="ruby-comment"># Get our PPI</span>
  <span class="ruby-identifier">ppi</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:force_ppi</span>, <span class="ruby-identifier">opts</span>[<span class="ruby-value">:parent</span>].<span class="ruby-identifier">ppi</span>).<span class="ruby-identifier">to_f</span>

  <span class="ruby-comment"># We&#39;re always deferred, create base</span>
  <span class="ruby-identifier">create_base_image</span>(<span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>({ <span class="ruby-value">force_ppi:</span> <span class="ruby-identifier">ppi</span> }))

  <span class="ruby-comment"># Convert pixel size into millimeters (in case we got +:force_size+)</span>
  <span class="ruby-ivar">@size_mm</span> = [<span class="ruby-ivar">@image</span>.<span class="ruby-identifier">width</span>, <span class="ruby-ivar">@image</span>.<span class="ruby-identifier">height</span>]
             .<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">px</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">px</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">ppi</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">MM_TO_INCH</span> }

  <span class="ruby-comment"># Set up some state</span>
  <span class="ruby-identifier">line_ypos</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">render_opts</span> = {
    <span class="ruby-value">font_name:</span> <span class="ruby-ivar">@font_name</span>,
    <span class="ruby-value">font_size:</span> <span class="ruby-ivar">@font_size</span>,
    <span class="ruby-value">color:</span> <span class="ruby-ivar">@color</span>,
    <span class="ruby-value">force_ppi:</span> <span class="ruby-identifier">ppi</span>,
    <span class="ruby-value">parent:</span> <span class="ruby-keyword">self</span>
  }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:text_render_opts</span>] <span class="ruby-operator">||</span> {})

  <span class="ruby-comment"># For each of our segment lines, wrap and render them using the</span>
  <span class="ruby-comment"># +render_text+ class method</span>
  <span class="ruby-ivar">@text_segment_lines</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mline</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line_segs</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">render_text</span>(<span class="ruby-identifier">mline</span>, <span class="ruby-ivar">@size_mm</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">render_opts</span>)

    <span class="ruby-identifier">line_segs</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span>, <span class="ruby-identifier">_line_idx</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">line_xpos</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">line_heights</span> = []

      <span class="ruby-identifier">line</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">textseg</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">ch_img</span> = <span class="ruby-identifier">textseg</span>.<span class="ruby-identifier">render_final</span>(<span class="ruby-identifier">render_opts</span>)

        <span class="ruby-comment"># Blit to our base image</span>
        <span class="ruby-identifier">ch_geometry</span> = <span class="ruby-node">&quot;+#{line_xpos}+#{line_ypos}&quot;</span>
        <span class="ruby-ivar">@image</span> = <span class="ruby-ivar">@image</span>.<span class="ruby-identifier">composite</span>(<span class="ruby-identifier">ch_img</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mg</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">mg</span>.<span class="ruby-identifier">define</span> <span class="ruby-string">&#39;png:color-type=6&#39;</span>

          <span class="ruby-identifier">mg</span>.<span class="ruby-identifier">compose</span> <span class="ruby-string">&#39;over&#39;</span>
          <span class="ruby-identifier">mg</span>.<span class="ruby-identifier">geometry</span> <span class="ruby-identifier">ch_geometry</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># Update our segment positioning</span>
        <span class="ruby-identifier">line_xpos</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">ch_img</span>.<span class="ruby-identifier">width</span>
        <span class="ruby-identifier">line_heights</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ch_img</span>.<span class="ruby-identifier">height</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">line_ypos</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">line_heights</span>.<span class="ruby-identifier">max</span> <span class="ruby-operator">+</span> (<span class="ruby-value">2</span> <span class="ruby-operator">*</span> <span class="ruby-constant">RcPdfLayout</span><span class="ruby-operator">::</span><span class="ruby-constant">MM_TO_INCH</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">ppi</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">line_heights</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Process queue on top of rendered text</span>
  <span class="ruby-identifier">image_queue_process</span>

  <span class="ruby-comment"># Return rendered image</span>
  <span class="ruby-ivar">@image</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

